'****************************************************************
'*  Name    : 46K22 SPI 9250 Test Dev-1.BAS                     *
'*  Author  : Andrew McEntee                                    *
'*  Notice  : Copyright (c) 2018 nth Solutions LLC.             *
'*          : All Rights Reserved                               *
'*  Date    : 3/9/2018                                         *
'*  Version : 1.0                                               *
'*  Notes   :                                                   *
'*          :                                                   *
'****************************************************************
'***************PROGRAMMER CONFIGURATIONS************************
'* OSCILLATOR: HS (MEDIUM POWER)                                *
'* PLL: ENABLED                                                 *
'* PRIMARY CLOCK: ENABLED                                       *
'* FAILSAFE CLOCK MONITOR: DISABLED                             *
'* INTERNAL EXTERNAL SWITCHOVER: DISABLED                       *
'* POWER UP TIMER: ENABLED                                      *
'* BROWN OUT RESET: DISABLED                                    *
'* BROWN OUT RESET VOLTAGE: 1.9V                                *
'* WATCHDOG TIMER: DISABLE (enable if no NAP's are used)      v  *
'* WATCHDOG TIMER POSTSCALER: 1:32768   (1:1 if NAP's are used) *
'* CCP2 MULTIPLEXED WITH: RC1                                   *
'* PORTB RESET STATE: DIGITAL I/O                               *
'* CCP3 MULTIPLEXED WITH: RB5                                   *
'* HFINTOSC FAST START: NOT DELAYED                             *
'* T3CKI MULTIPLEXED WITH: RC0                                  *
'* CCP2 B MULTPLEXED WITH: RB5                                  *
'* MCLR FUNCTION: INPUT PIN                                     *
'* STACK OVERFLOW/ UNDERFLOW RESET: DISABLED                    *
'* LOW VOLTAGE PROGRAMMING: DISABLED                            *
'* ENHANCED CPU: DISABLED                                       *
'* BOOT BLOCK: NOT PROTECTED                                    *                                                               
'* EVERYTHING ELSE: NOT PROTECTED                               *
'****************************************************************

include "MODEDEFS.BAS"
define OSC 32        
   
OSCCON = %11101000		'USE CRYSTAL OSCILLATOR AT 8 MHZ
OSCCON2 = %10000000		'ENABLE 4xPLL
OSCTUNE = %01000000		'ENABLE 4xPLL FOR INTOSC
INTCON = %00000000      'DISABLE ALL INTERRUPTS, ENABLED LATER IN INIT_TMR0 SUBROUTINE
WPUB = %00000000        'DISABLE PULLUPS ON PORTB
ANSELA = %00000000      'SET ALL A PORTS TO DIGITAL
ANSELB = %00000000      'SET ALL B PORTS TO DIGITAL
ANSELC = %00000000      'SET ALL C PORTS TO DIGITAL
TRISE = %00000001       'DISABLE PULLUPS ON PORTE

'THESE DEFAULTS WILL ONLY BE IMPLEMENTED AFTER THE MODULE IS FRESHLY PROGRAMMED OR THE PIC'S INTERNAL EEPROM IS ERASED/ CORRUPTED
DEF_ACCEL_GYRO_SAMPLE_RATE   CON   120                  'DEFAULTS ACCEL AND GYRO SAMPLE RATE TO 120HZ
DEF_MAG_SAMPLE_RATE          CON   120                  'DEFAULTS MAG SAMPLE RATE TO 50HZ
DEF_TEST_DURATION            CON   5                    'DEFAULTS TEST DURATION TO 30 SECONDS
DEF_ACCEL_SENSITIVITY        CON   8                    'DEFAULTS ACCEL SENSITIVITY TO 8G
DEF_GYRO_SENSITIVITY         CON   1000                 'DEFAULTS GYRO SENSITIVITY TO 100DPS
DEF_ACCEL_FILTER             CON   92                   'DEFAULTS ACCEL FILTER TO 92HZ
DEF_GYRO_FILTER              CON   92                   'DEFAULTS GYRO FILTER TO 92HZ


'MPU-9250 CONFIG DATA
PWR_MGMT_1_DATA         con     %00000001               'USE INTERNAL 20MHZ OSCILLATOR AS CLOCK SOURCE FOR MPU-9250
PWR_MGMT_2_DATA         con     %00000000               'ENABLE GYRO AND ACCEL IN ALL DIMENSIONS
INT_PIN_CFG_DATA        CON     %00010010               'DISBALE INTERRUPTS
INT_ENABLE_DATA         CON     %00000001               'DISABLE INTERRUPTS
CNTL1_CONFIG_DATA       con     %00010001               '16 BIT RESOLUTION, SINGLE SHOT MODE (TAKES 10MS TO SAMPLE MINIMUM)               
MPU_RESET_CMD           con     $80                     'SENT TO PWR_MGMT_1_ADDR TO RESET THE MPU-9250

MAG_ADDR_W    con     $18                                   'WRITE ADDRESS OF THE AK8963 MAG
MAG_ADDR_R    con     $19                                   'READ ADDRESS OF THE AK8963 MAG
'MPU9250 REGISTER ADDRESSES
MAG_XOUT_L_ADDR       con $03                              'SEE MPU-9250 REGISTER MAP FOR MORE INFO:
                                                                 '\\ELEANOR\DOCUMENTS\_URICCHIO PROJECT\MPU-9250 DOCUMENTATION - "MPU-9250 REGISTER MAP - NA - INVENSENSE - JAN 2015"
MAG_XOUT_H_ADDR       con $04
MAG_YOUT_L_ADDR       con $05
MAG_YOUT_H_ADDR       con $06
MAG_ZOUT_L_ADDR       con $07
MAG_ZOUT_H_ADDR       con $08
CNTL1_ADDR            con $0A
CNTL2_ADDR            con $0B
XACCEL_FACT_ST        con $0D
YACCEL_FACT_ST        con $0E
ZACCEL_FACT_ST        con $0F
SMPLRT_DIV_ADDR       con $19
GEN_CONFIG_ADDR       con $1A
GYRO_CONFIG_ADDR      con $1B
ACCEL_CONFIG_ADDR     con $1C
ACCEL_CONFIG_2_ADDR   con $1D
I2C_MSTR_ADDR         con $24
INT_PIN_CFG_ADDR      con $37
INT_ENABLE_ADDR       con $38
INT_STATUS_ADDR       con $3A
ACCEL_XOUT_H_ADDR     con $3B
ACCEL_XOUT_L_ADDR     con $3C
ACCEL_YOUT_H_ADDR     con $3D
ACCEL_YOUT_L_ADDR     con $3E
ACCEL_ZOUT_H_ADDR     con $3F
ACCEL_ZOUT_L_ADDR     con $40
TEMP_OUT_H_ADDR       con $41
TEMP_OUT_L_ADDR       con $42
GYRO_XOUT_H_ADDR      con $43
GYRO_XOUT_L_ADDR      con $44
GYRO_YOUT_H_ADDR      con $45
GYRO_YOUT_L_ADDR      con $46
GYRO_ZOUT_H_ADDR      con $47
GYRO_ZOUT_L_ADDR      con $48
USER_CONTROL_ADDR     con $6A
PWR_MGMT_1_ADDR       con $6B
PWR_MGMT_2_ADDR       con $6C
MPU_WHO_AM_I_ADDR     CON $75
XA_OFFS_H_ADDR        con $77
XA_OFFS_L_ADDR        con $78
YA_OFFS_H_ADDR        con $79
YA_OFFS_L_ADDR        con $80
ZA_OFFS_H_ADDR        con $81
ZA_OFFS_L_ADDR        con $82

READ_FLAG             CON $80



'Set Pin Aliases                            'DIP-40 Package
MPU9250_CS          var     PORTA.3     'Pin 5 
SCK                 var     PORTC.3     'Pin 18
SDO                 var     PORTC.4     'Pin 23
SDI                 var     PORTC.5     'Pin 24
INT_PIN             var     PORTB.3     'PIN 36
UART_TX             var     PORTC.7     'Pin 26
UART_RX             var     PORTB.0     'Pin 33
BLUE_LED            var     PORTD.1     'PIN 20

TMR0_TICK_THRESHOLD CON     33333       'THIS IS THE NUMBER THAT TMR0 WILL COUNT TO BEFORE ROLLING OVER 
                                        '!!ASSUME PRESCALER OF 2 WITH 8MHZ SOURCE  SO PRECISION IS 250nS

'UART VARIABLES AND CONSTANTS
HEX_RETURN              VAR     BYTE                             'GLOBAL VARIABLE THAT STORES THE RESULT OF THE STRING TO HEX CONVERSION
TX_DATA				    var		byte                             'VARIABLE THAT STORES WHAT WILL BE TRANSMITTED VIA UART
TX_BYTE				    VAR		BYTE                             'VARIABLE THAT WILL BE CONVERTED TO HEX BEFORE TRANSMITTING VIA UART
BIT_INDEX 			    var	    Byte                             'USED TO BIT BANG UART
HEX_DIGIT_COUNTER	    VAR	    BYTE                             'USED TO CONVERT A BYTE TO HEX
HEX_INDEX			    VAR	    BYTE                             'USED TO CONVERT A BYTE TO HEX
RAW_RX_DATA             VAR     BYTE[28]                         'BYTE ARRAY THAT STORES TEST PARAMETERS SENT FROM THE PC 
TEMP_BYTE               var     BYTE                             'TEMPORARILY STORES A BYTE FOR DATA CONVERSION
SERIAL_COUNTER          var     BYTE                             'USED TO NAVIGATE IN SERIAL DATA TRANSMISSION

'DATA STORAGE VARIABLES (MPU-9250)
RAW_ACCEL_GYRO_DATA     VAR     BYTE[12]            'STORES RAW DATA FROM 9250 ACCEL AND GYRO REGISTERS MSB FIRST(INDEX 0-5 = ACCEL XYZ, 6-11 = GYRO XYZ)
GEN_CONFIG_DATA         VAR     BYTE                'STORES THE ACTUAL VALUE THAT WILL BE SENT TO THE GEN_CONFIG REGISTER
GYRO_CONFIG_DATA        VAR     BYTE                'STORES THE ACTUAL VALUE THAT WILL BE SENT TO THE GYRO_CONFIG REGISTER
ACCEL_CONFIG_DATA       VAR     BYTE                'STORES THE ACTUAL VALUE THAT WILL BE SENT TO THE ACCEL_CONFIG REGISTER
ACCEL_CONFIG_2_DATA     VAR     BYTE                'STORES THE ACTUAL VALUE THAT WILL BE SENT TO THE ACCEL_CONFIG_2 REGISTER
DUMMY                   VAR     BYTE
DEVICE_ID               VAR     BYTE


UART_PERIOD_VAR_115200 	con		2        'DO NOT CHANGE, CRITICAL FOR UART

'GENERIC INCREMENTAL VARIABLES
I                   var     word

INIT_PORTS:
    output UART_TX
    output BLUE_LED
    output MPU9250_CS
    OUTPUT SDI
    OUTPUT SCK
    
    input UART_RX
    input INT_PIN
    INPUT SDO
INIT_COMM_BUSSES:
    GOSUB CALIBRATE_UART
    gosub INIT_SPI
    GOSUB CALIBRATE_SPI
    GOSUB INIT_MPU
    PAUSE 100               'ALLOW BUSES TO INITIALIZE
MAIN:  
    WHILE 1 == 1
        GOSUB READ_9AXIS

        BLUE_LED = 1
        GOSUB PRINT_9AXIS
        GOSUB UART_CRLF
        BLUE_LED = 0
        wend                        

INIT_MPU:                                     'INITIALIZES PROGRAM VARIABLES AND MPU REGISTERS
    GOSUB SET_ACCEL_SENS_VAR                  'INITIALIZE VARIABLE FOR THE ACCELEROMETER SENSITIVITY BASED ON CONSTANTS AT THE TOP
    GOSUB SET_GYRO_SENS_VAR                   'INITIALIZE VARIABLE FOR THE GYROSCOPE SENSITIVITY BASED ON CONSTANTS AT THE TOP
    GOSUB SET_ACCEL_FILTER_VAR                'INITIALIZE VARIABLE FOR THE ACCELEROMETER FILTER BASED ON CONSTANTS AT THE TOP
    GOSUB SET_GYRO_FILTER_VAR                 'INITIALIZE VARIABLE FOR THE GYROSCOPE FILTER BASED ON CONSTANTS AT THE TOP
    
    'VERIFY THE MPU9250 IS ON THE BUS AND OPERATIONAL
    MPU9250_CS = 0                            'WAKE UP 9250        
    SSP1BUF = MPU_WHO_AM_I_ADDR | READ_FLAG  'TELL 9250 THE REGISTER THAT YOU WANT TO ACCESS
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF                           '
    SSP1BUF = 0                               'SEND DATA TO REGISTER
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DEVICE_ID = SSP1BUF                       'STORE THE DEVICE ID
    MPU9250_CS = 1                            'END SEQUENCE
    IF DEVICE_ID != $70 THEN
        GOTO MPU_ERROR
        ENDIF
    
    
    
    'RESET 9250
    MPU9250_CS = 0                            'WAKE UP 9250        
    SSP1BUF = PWR_MGMT_1_ADDR                 'TELL 9250 THE REGISTER THAT YOU WANT TO ACCESS
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF                           'CLEAR THE BUFFER FULL FLAG BY READING THE DATA (SSP1STAT.0) 
    SSP1BUF = MPU_RESET_CMD                   'SEND DATA TO REGISTER
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF                           'CLEAR THE BUFFER FULL FLAG BY READING THE DATA (SSP1STAT.0) 
    MPU9250_CS = 1                            'TELL 9250 TO EXECUTE THE COMMAND JUST PASSED IN
    
    PAUSE 10                                  'WAIT FOR 9250 TO RESET (TO BE CAUTIOUS)
    
    'CONFIGURE 9250, SEE CONSTANTS FOR MORE INFO
    MPU9250_CS = 0                            'WAKE UP 9250        
    SSP1BUF = PWR_MGMT_1_ADDR                 'TELL 9250 THE REGISTER THAT YOU WANT TO ACCESS
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF                           'CLEAR THE BUFFER FULL FLAG BY READING THE DATA (SSP1STAT.0)                           'CLEAR THE BUFFER FULL FLAG BY READING THE DATA (SSP1STAT.0)
    SSP1BUF = PWR_MGMT_1_DATA                 'SEND DATA TO REGISTER
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF                           'CLEAR THE BUFFER FULL FLAG BY READING THE DATA (SSP1STAT.0)
    MPU9250_CS = 1                            'TELL 9250 TO EXECUTE THE COMMAND JUST PASSED IN
    
    MPU9250_CS = 0                            'WAKE UP 9250        
    SSP1BUF = PWR_MGMT_2_ADDR                 'TELL 9250 THE REGISTER THAT YOU WANT TO ACCESS
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF                           'CLEAR THE BUFFER FULL FLAG BY READING THE DATA (SSP1STAT.0)
    SSP1BUF = PWR_MGMT_2_DATA                 'SEND DATA TO REGISTER
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF                           'CLEAR THE BUFFER FULL FLAG BY READING THE DATA (SSP1STAT.0)
    MPU9250_CS = 1                            'TELL 9250 TO EXECUTE THE COMMAND JUST PASSED IN
    
    MPU9250_CS = 0                            'WAKE UP 9250        
    SSP1BUF = GEN_CONFIG_ADDR                 'TELL 9250 THE REGISTER THAT YOU WANT TO ACCESS
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF                           'CLEAR THE BUFFER FULL FLAG BY READING THE DATA (SSP1STAT.0)
    SSP1BUF = GEN_CONFIG_DATA                 'SEND DATA TO REGISTER
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF                           'CLEAR THE BUFFER FULL FLAG BY READING THE DATA (SSP1STAT.0)
    MPU9250_CS = 1                            'TELL 9250 TO EXECUTE THE COMMAND JUST PASSED IN
                                              
    MPU9250_CS = 0                            'WAKE UP 9250        
    SSP1BUF = GYRO_CONFIG_ADDR                'TELL 9250 THE REGISTER THAT YOU WANT TO ACCESS
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF                           'CLEAR THE BUFFER FULL FLAG BY READING THE DATA (SSP1STAT.0)
    SSP1BUF = GYRO_CONFIG_DATA                'SEND DATA TO REGISTER
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF                           'CLEAR THE BUFFER FULL FLAG BY READING THE DATA (SSP1STAT.0)
    MPU9250_CS = 1                            'TELL 9250 TO EXECUTE THE COMMAND JUST PASSED IN
    
    MPU9250_CS = 0                            'WAKE UP 9250        
    SSP1BUF = ACCEL_CONFIG_ADDR               'TELL 9250 THE REGISTER THAT YOU WANT TO ACCESS
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF                           'CLEAR THE BUFFER FULL FLAG BY READING THE DATA (SSP1STAT.0)
    SSP1BUF = ACCEL_CONFIG_DATA               'SEND DATA TO REGISTER
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF                           'CLEAR THE BUFFER FULL FLAG BY READING THE DATA (SSP1STAT.0)
    MPU9250_CS = 1                            'TELL 9250 TO EXECUTE THE COMMAND JUST PASSED IN
                                              
    MPU9250_CS = 0                            'WAKE UP 9250        
    SSP1BUF = ACCEL_CONFIG_2_ADDR             'TELL 9250 THE REGISTER THAT YOU WANT TO ACCESS
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF                           'CLEAR THE BUFFER FULL FLAG BY READING THE DATA (SSP1STAT.0)
    SSP1BUF = ACCEL_CONFIG_2_DATA             'SEND DATA TO REGISTER
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF                           'CLEAR THE BUFFER FULL FLAG BY READING THE DATA (SSP1STAT.0)
    MPU9250_CS = 1    
    
    MPU9250_CS = 0                            'WAKE UP 9250        
    SSP1BUF = INT_PIN_CFG_ADDR                'TELL 9250 THE REGISTER THAT YOU WANT TO ACCESS
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF                           'CLEAR THE BUFFER FULL FLAG BY READING THE DATA (SSP1STAT.0)
    SSP1BUF = INT_PIN_CFG_DATA                'SEND DATA TO REGISTER
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF                           'CLEAR THE BUFFER FULL FLAG BY READING THE DATA (SSP1STAT.0)
    MPU9250_CS = 1 

    
    MPU9250_CS = 0                            'WAKE UP 9250        
    SSP1BUF = INT_ENABLE_ADDR                 'TELL 9250 THE REGISTER THAT YOU WANT TO ACCESS
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF                           'CLEAR THE BUFFER FULL FLAG BY READING THE DATA (SSP1STAT.0)
    SSP1BUF = INT_ENABLE_DATA                 'SEND DATA TO REGISTER
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF                           'CLEAR THE BUFFER FULL FLAG BY READING THE DATA (SSP1STAT.0)
    MPU9250_CS = 1   
    
    MPU9250_CS = 0                            'WAKE UP 9250        
    SSP1BUF = CNTL1_ADDR                      'TELL 9250 THE REGISTER THAT YOU WANT TO ACCESS
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF                           'CLEAR THE BUFFER FULL FLAG BY READING THE DATA (SSP1STAT.0)
    SSP1BUF = CNTL1_CONFIG_DATA               'SEND DATA TO REGISTER
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF                           'CLEAR THE BUFFER FULL FLAG BY READING THE DATA (SSP1STAT.0)
    MPU9250_CS = 1 
    
    'VERIFY ALL AXIS OF THE ACCEL AND GYRO ARE ENABLED
    MPU9250_CS = 0                            'WAKE UP 9250        
    SSP1BUF = PWR_MGMT_2_ADDR | READ_FLAG     'TELL 9250 THE REGISTER THAT YOU WANT TO ACCESS
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF
    SSP1BUF = 0                               'SEND DATA TO REGISTER
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF
    MPU9250_CS = 1                            'TELL 9250 TO EXECUTE THE COMMAND JUST PASSED IN
    IF DUMMY != $00 THEN
        GOTO MPU_ERROR
        ENDIF
return

SET_ACCEL_SENS_VAR:                                               'SET CONFIGURATION BITS TO MATCH THE ACCEL_SENSITIVITY CONSTANT
    SELECT CASE DEF_ACCEL_SENSITIVITY                                 'SELECT THE CASE BASED ON THE VALUE OF ACCEL_SENSITIVITY
        CASE 2                                                    '2G
             ACCEL_CONFIG_DATA.4 = 0
             ACCEL_CONFIG_DATA.3 = 0    
        CASE 4                                                    '4G
             ACCEL_CONFIG_DATA.4 = 0
             ACCEL_CONFIG_DATA.3 = 1    
        CASE 8                                                    '8G
             ACCEL_CONFIG_DATA.4 = 1
             ACCEL_CONFIG_DATA.3 = 0    
        CASE 16                                                   '16G
             ACCEL_CONFIG_DATA.4 = 1
             ACCEL_CONFIG_DATA.3 = 1    
        CASE ELSE                                                'EXECUTES IF THE USER DID NOT INPUT A VALID NUMBER (8G)
             ACCEL_CONFIG_DATA.4 = 1
             ACCEL_CONFIG_DATA.3 = 0  
    END SELECT
RETURN

SET_GYRO_SENS_VAR:                                               'SET CONFIGURATION BITS TO MATCH THE GYRO_SENSITIVITY CONSTANT
    SELECT CASE DEF_GYRO_SENSITIVITY                                 'SELECT THE CASE BASED ON THE VALUE OF GYRO_SENSITIVITY
        CASE 250                                                 '250DPS
             GYRO_CONFIG_DATA.4 = 0
             GYRO_CONFIG_DATA.3 = 0    
        CASE 500                                                 '500DPS
             GYRO_CONFIG_DATA.4 = 0
             GYRO_CONFIG_DATA.3 = 1    
        CASE 1000                                                '1000DPS
             GYRO_CONFIG_DATA.4 = 1
             GYRO_CONFIG_DATA.3 = 0    
        CASE 2000                                                '2000DPS
             GYRO_CONFIG_DATA.4 = 1
             GYRO_CONFIG_DATA.3 = 1    
        CASE ELSE                                                'EXECUTES IF THE USER DID NOT INPUT A VALID NUMBER (500DPS)
             GYRO_CONFIG_DATA.4 = 0
             GYRO_CONFIG_DATA.3 = 1
    END SELECT
RETURN
SET_ACCEL_FILTER_VAR:                                           'SET CONFIGURATION BITS TO MATCH THE ACCEL_FILTER CONSTANT
    SELECT CASE DEF_ACCEL_FILTER                                    'SELECT THE CASE BASED ON THE VALUE OF ACCEL_FILTER
        CASE 5                                                  '5 HZ
             ACCEL_CONFIG_2_DATA.3 = 1
             ACCEL_CONFIG_2_DATA.2 = 1
             ACCEL_CONFIG_2_DATA.1 = 1 
             ACCEL_CONFIG_2_DATA.0 = 0     
        CASE 10                                                 '10 HZ
             ACCEL_CONFIG_2_DATA.3 = 1
             ACCEL_CONFIG_2_DATA.2 = 1
             ACCEL_CONFIG_2_DATA.1 = 0 
             ACCEL_CONFIG_2_DATA.0 = 1  
        CASE 20                                                 '20 HZ
             ACCEL_CONFIG_2_DATA.3 = 1
             ACCEL_CONFIG_2_DATA.2 = 1
             ACCEL_CONFIG_2_DATA.1 = 0 
             ACCEL_CONFIG_2_DATA.0 = 0  
        CASE 41                                                 '41 HZ
             ACCEL_CONFIG_2_DATA.3 = 1
             ACCEL_CONFIG_2_DATA.2 = 0
             ACCEL_CONFIG_2_DATA.1 = 1 
             ACCEL_CONFIG_2_DATA.0 = 1            
        CASE 92                                                 '92 HZ
             ACCEL_CONFIG_2_DATA.3 = 1
             ACCEL_CONFIG_2_DATA.2 = 0
             ACCEL_CONFIG_2_DATA.1 = 1 
             ACCEL_CONFIG_2_DATA.0 = 0  
        CASE 184                                                '184 HZ
             ACCEL_CONFIG_2_DATA.3 = 1
             ACCEL_CONFIG_2_DATA.2 = 0
             ACCEL_CONFIG_2_DATA.1 = 0
             ACCEL_CONFIG_2_DATA.0 = 1  
        CASE 460                                                '460 HZ
             ACCEL_CONFIG_2_DATA.3 = 1
             ACCEL_CONFIG_2_DATA.2 = 0
             ACCEL_CONFIG_2_DATA.1 = 0 
             ACCEL_CONFIG_2_DATA.0 = 0  
        CASE 1130                                              '1130 HZ
             ACCEL_CONFIG_2_DATA.3 = 0
             ACCEL_CONFIG_2_DATA.2 = 0
             ACCEL_CONFIG_2_DATA.1 = 0 
             ACCEL_CONFIG_2_DATA.0 = 0  
        CASE ELSE                                                   'EXECUTES IF THE USER DID NOT INPUT A VALID NUMBER (92HZ)
             ACCEL_CONFIG_2_DATA.3 = 1
             ACCEL_CONFIG_2_DATA.2 = 0
             ACCEL_CONFIG_2_DATA.1 = 1 
             ACCEL_CONFIG_2_DATA.0 = 0   
    END SELECT
RETURN
SET_GYRO_FILTER_VAR:                                                'SET CONFIGURATION BITS TO MATCH THE GYRO_FILTER CONSTANT
    SELECT CASE DEF_GYRO_FILTER                                         'SELECT THE CASE BASED ON THE VALUE OF GYRO_FILTER
        CASE 5                                                      '5 HZ
             GYRO_CONFIG_DATA.1 = 1
             GYRO_CONFIG_DATA.0 = 1 
             GEN_CONFIG_DATA.2 = 1
             GEN_CONFIG_DATA.1 = 1 
             GEN_CONFIG_DATA.0 = 0                                  '10 HZ
        CASE 10
             GYRO_CONFIG_DATA.1 = 1
             GYRO_CONFIG_DATA.0 = 1
             GEN_CONFIG_DATA.2 = 1
             GEN_CONFIG_DATA.1 = 0 
             GEN_CONFIG_DATA.0 = 1  
        CASE 20                                                     '20 HZ
             GYRO_CONFIG_DATA.1 = 1
             GYRO_CONFIG_DATA.0 = 1
             GEN_CONFIG_DATA.2 = 1
             GEN_CONFIG_DATA.1 = 0 
             GEN_CONFIG_DATA.0 = 0  
        CASE 41                                                     '41 HZ
             GYRO_CONFIG_DATA.1 = 1
             GYRO_CONFIG_DATA.0 = 1
             GEN_CONFIG_DATA.2 = 0
             GEN_CONFIG_DATA.1 = 1 
             GEN_CONFIG_DATA.0 = 1            
        CASE 92                                                     '92 HZ
             GYRO_CONFIG_DATA.1 = 1
             GYRO_CONFIG_DATA.0 = 1
             GEN_CONFIG_DATA.2 = 0
             GEN_CONFIG_DATA.1 = 1 
             GEN_CONFIG_DATA.0 = 0  
        CASE 184                                                    '184 HZ
             GYRO_CONFIG_DATA.1 = 1
             GYRO_CONFIG_DATA.0 = 1
             GEN_CONFIG_DATA.2 = 0
             GEN_CONFIG_DATA.1 = 0
             GEN_CONFIG_DATA.0 = 1  
        CASE 250                                                    '250 HZ
             GYRO_CONFIG_DATA.1 = 1
             GYRO_CONFIG_DATA.0 = 1
             GEN_CONFIG_DATA.2 = 0
             GEN_CONFIG_DATA.1 = 0 
             GEN_CONFIG_DATA.0 = 0  
        CASE 3600                                                   '3600 HZ
             GYRO_CONFIG_DATA.1 = 0
             GYRO_CONFIG_DATA.0 = 1
             GEN_CONFIG_DATA.2 = 0
             GEN_CONFIG_DATA.1 = 0 
             GEN_CONFIG_DATA.0 = 0
        CASE 8800                                                   '8800 HZ
             GYRO_CONFIG_DATA.1 = 0
             GYRO_CONFIG_DATA.0 = 0
             GEN_CONFIG_DATA.2 = 0
             GEN_CONFIG_DATA.1 = 0 
             GEN_CONFIG_DATA.0 = 0  
        CASE ELSE                                                   'EXECUTES IF THE USER DID NOT INPUT A VALID NUMBER (92HZ)
             GYRO_CONFIG_DATA.1 = 1
             GYRO_CONFIG_DATA.0 = 1
             GEN_CONFIG_DATA.2 = 0
             GEN_CONFIG_DATA.1 = 1 
             GEN_CONFIG_DATA.0 = 0   
    END SELECT
RETURN

READ_9AXIS:
    'ACCELEROMETER
    MPU9250_CS = 0                            'CS GOES LOW TO START A SEQUENCE                        
    SSP1BUF = ACCEL_XOUT_H_ADDR | read_flag   'SEND 1 BYTE OF THE DESIRED ADDRESS MASKED WITH THE READ FLAG TO THE 9250
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF                           'CLEAR THE BUFFER FULL FLAG BY READING THE DATA (SSP1STAT.0)
    
    'X AXIS
    SSP1BUF = 0                               'RECEIVE NEXT BYTE OF DATA
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND                                      'RECEIVE NEXT BYTE OF DATA
    RAW_ACCEL_GYRO_DATA[1] = SSP1BUF          'STORE DATA AND AUTOMATICALLY CLEAR THE BUFFER FULL FLAG (SSP1STAT.0)
    SSP1BUF = 0                               'RECEIVE NEXT BYTE OF DATA
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND                                      'RECEIVE NEXT BYTE OF DATA
    RAW_ACCEL_GYRO_DATA[0] = SSP1BUF          'STORE DATA AND AUTOMATICALLY CLEAR THE BUFFER FULL FLAG (SSP1STAT.0)
    
    'Y AXIS
    SSP1BUF = 0                               'RECEIVE NEXT BYTE OF DATA
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND                                      'RECEIVE NEXT BYTE OF DATA
    RAW_ACCEL_GYRO_DATA[3] = SSP1BUF          'STORE DATA AND AUTOMATICALLY CLEAR THE BUFFER FULL FLAG (SSP1STAT.0)
    SSP1BUF = 0                               'RECEIVE NEXT BYTE OF DATA
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND                                      'RECEIVE NEXT BYTE OF DATA
    RAW_ACCEL_GYRO_DATA[2] = SSP1BUF          'STORE DATA AND AUTOMATICALLY CLEAR THE BUFFER FULL FLAG (SSP1STAT.0)
    
    
    'Z AXIS
    SSP1BUF = 0                               'RECEIVE NEXT BYTE OF DATA
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND                                      'RECEIVE NEXT BYTE OF DATA
    RAW_ACCEL_GYRO_DATA[5] = SSP1BUF          'STORE DATA AND AUTOMATICALLY CLEAR THE BUFFER FULL FLAG (SSP1STAT.0)
    SSP1BUF = 0                               'RECEIVE NEXT BYTE OF DATA
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND                                      'RECEIVE NEXT BYTE OF DATA
    RAW_ACCEL_GYRO_DATA[4] = SSP1BUF          'STORE DATA AND AUTOMATICALLY CLEAR THE BUFFER FULL FLAG (SSP1STAT.0)
    MPU9250_CS = 1 
    
    'GYROSCOPE
    MPU9250_CS = 0                            'CS GOES LOW TO START A SEQUENCE                        
    SSP1BUF = GYRO_XOUT_H_ADDR | read_flag    'SEND 1 BYTE OF THE DESIRED ADDRESS MASKED WITH THE READ FLAG TO THE 9250
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND
    DUMMY = SSP1BUF                           'CLEAR THE BUFFER FULL FLAG BY READING THE DATA (SSP1STAT.0)
    
    'X AXIS
    SSP1BUF = 0                               'RECEIVE NEXT BYTE OF DATA
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND                                      'RECEIVE NEXT BYTE OF DATA
    RAW_ACCEL_GYRO_DATA[7] = SSP1BUF          'STORE DATA AND AUTOMATICALLY CLEAR THE BUFFER FULL FLAG (SSP1STAT.0)
    SSP1BUF = 0                               'RECEIVE NEXT BYTE OF DATA
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND                                      'RECEIVE NEXT BYTE OF DATA
    RAW_ACCEL_GYRO_DATA[6] = SSP1BUF          'STORE DATA AND AUTOMATICALLY CLEAR THE BUFFER FULL FLAG (SSP1STAT.0)
    
    'Y AXIS
    SSP1BUF = 0                               'RECEIVE NEXT BYTE OF DATA
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND                                      'RECEIVE NEXT BYTE OF DATA
    RAW_ACCEL_GYRO_DATA[9] = SSP1BUF          'STORE DATA AND AUTOMATICALLY CLEAR THE BUFFER FULL FLAG (SSP1STAT.0)
    SSP1BUF = 0                               'RECEIVE NEXT BYTE OF DATA
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND                                      'RECEIVE NEXT BYTE OF DATA
    RAW_ACCEL_GYRO_DATA[8] = SSP1BUF          'STORE DATA AND AUTOMATICALLY CLEAR THE BUFFER FULL FLAG (SSP1STAT.0)
    
    
    'Z AXIS
    SSP1BUF = 0                               'RECEIVE NEXT BYTE OF DATA
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND                                      'RECEIVE NEXT BYTE OF DATA
    RAW_ACCEL_GYRO_DATA[11] = SSP1BUF          'STORE DATA AND AUTOMATICALLY CLEAR THE BUFFER FULL FLAG (SSP1STAT.0)
    SSP1BUF = 0                               'RECEIVE NEXT BYTE OF DATA
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND                                      'RECEIVE NEXT BYTE OF DATA
    RAW_ACCEL_GYRO_DATA[10] = SSP1BUF          'STORE DATA AND AUTOMATICALLY CLEAR THE BUFFER FULL FLAG (SSP1STAT.0)
    MPU9250_CS = 1 
RETURN 

PRINT_9AXIS:
    FOR I = 0 TO 10 STEP 2
        TX_BYTE = RAW_ACCEL_GYRO_DATA[I + 1]
        GOSUB TX_HEX_BYTE_115200
        TX_BYTE = RAW_ACCEL_GYRO_DATA[I]
        GOSUB TX_HEX_BYTE_115200
        TX_DATA = 44
        GOSUB UART_TX_VAR_115200
        NEXT I
RETURN
    
'****************ERROR SUBROUTINES************************************************************
MPU_ERROR:                  'INFINITE LED BLINK ERROR LOOP
    WHILE 1 == 1
        BLUE_LED = 1
        PAUSE 500
        BLUE_LED = 0
        PAUSE 500
        WEND
RETURN   
'****************FUNDAMENTAL SPI SUBROUTINES**************************************************
INIT_SPI:                   'SETS NECESSARY REGISTERS FOR HARDWARE SPI
    SSP1STAT = %00000000    'DATA SAMPLED IN MIDDLE OF DATA OUTPUT TIME, TRANSMIT OCCURS ON TRANSITION FROM IDLE TO ACTIVE CLOCK, RESET FLAGS
    SSP1CON1 = %00110000    'ENABLE MSSP MODULE, ENABLE SPI AS MASTER WITH CLOCK SPEED = FOSC/4, CLOCK IDLES HIGH 
    SSP1CON3 = %00010000    'ENABLE BUFFER OVERWRITING SO IF THE DATA IS WRITTEN TO THE BUFFER WHILE A WRITE IS IN PROGRESS THE MSSP DOESN'T CRASH
    MPU9250_CS = 1
RETURN

CALIBRATE_SPI:                                'DO NOT ATTEMPT TO TALK TO PART, JUST SHIFT DATA OUT ON THE BUS TO INITIALIZE THE BUFFER
    SSP1BUF = 0                               'RECEIVE NEXT BYTE OF DATA
    WHILE SSP1STAT.0 == 0                     'WAIT FOR TRANSMISSION TO COMPLETE
    WEND                                      'RECEIVE NEXT BYTE OF DATA
    DUMMY = SSP1BUF                           'STORE DATA AND AUTOMATICALLY CLEAR THE BUFFER FULL FLAG (SSP1STAT.0)
RETURN
'****************FUNDAMENTAL UART SUBROUTINES*************************************************		
CALIBRATE_UART:
    for I = 0 to 25
        TX_DATA = 0
        gosub UART_TX_VAR_115200
        next I
return	
UART_CRLF:
    TX_DATA = 13  
    gosub UART_TX_VAR_115200  
    TX_DATA = 10
    gosub UART_TX_VAR_115200     
RETURN
    	
TX_HEX_BYTE_115200:                     'CONVERTS VALUE IN TX_BYTE VARIABLE TO HEXADECIMAL STRING AND TRANSMITS IT VIA UART (ASCII) (NOT USED IN THIS REVISION)
	FOR HEX_DIGIT_COUNTER = 0 TO 1      'LOOPS THROUGH BOTH DIGITS OF THE HEX BYTE
		IF HEX_DIGIT_COUNTER == 0 THEN  'EXECUTES IF THE PROGRAM IS CURRENTLY DETERMINING HOW LARGE THE 16'S PLACE DIGIT SHOULD BE
			HEX_INDEX = TX_BYTE/16      'DETERMINES WHICH CHARACTER TO LOOK UP IN THE SELECT CASE
		ELSE                            'EXECUTES IF THE PROGRAM IS CURRENTLY DETERMINING HOW LARGE THE 1'S PLACE DIGIT SHOULD BE
			HEX_INDEX = TX_BYTE // 16   'DETERMINES WHICH CHARACTER TO LOOK UP IN THE SELECT CASE
			ENDIF
		
		SELECT CASE HEX_INDEX           'LOOK UP WHICH ASCII CHARACTER CORRESPONDS TO THE HEX_INDEX (EX. HEX_INDEX = 14, ASCII EQUIVALENT IS "E") 
			CASE 0
				TX_DATA = "0"
			CASE 1
				TX_DATA = "1"
			CASE 2
				TX_DATA = "2"
			CASE 3
				TX_DATA = "3"
			CASE 4
				TX_DATA = "4"
			CASE 5
				TX_DATA = "5"
			CASE 6
				TX_DATA = "6"
			CASE 7
				TX_DATA = "7"
			CASE 8
				TX_DATA = "8"
			CASE 9
				TX_DATA = "9"
			CASE 10
				TX_DATA = "A"
			CASE 11
				TX_DATA = "B"
			CASE 12
				TX_DATA = "C"
			CASE 13
				TX_DATA = "D"
			CASE 14
				TX_DATA = "E"
			CASE 15
				TX_DATA = "F"
			END SELECT	
		gosub UART_TX_VAR_115200        'TRANMSIT THE VALUE OF TX_BYTE AT 115200 BAUD
	NEXT HEX_DIGIT_COUNTER              'LOOP
RETURN
		
UART_TX_VAR_115200:                     'TRANSMITS VALUE OF TX_DATA VARIABLE OVER UART AT 115200 BAUD (BIT BANGED)
	OUTPUT UART_TX                      'Change UART_TX from INPUT to OUTPUT (Set as INPUT when UART not is use to avoid programming conflicts)
    UART_TX = 0							'START BIT
	pauseus UART_PERIOD_VAR_115200		'DELAY TO REACH APPROXIMATE PULSE WIDTH
	gosub waste_time                	'USED FOR PULSE WIDTH TUNING
	gosub waste_time                	'USED FOR PULSE WIDTH TUNING
    for BIT_INDEX = 0 to 7              'LOOPS THROUGH EACH BIT OF THE VARIABLE
		UART_TX = TX_DATA.0[BIT_INDEX]  'LOOKUP BIT STATE LSB FIRST
		pauseus UART_PERIOD_VAR_115200  'DELAY TO REACH APPROXIMATE PULSE WIDTH
		gosub waste_time                'USED FOR PULSE WIDTH TUNING
		next BIT_INDEX
	pauseus 3                           'DELAY TO REACH APPROXIMATE PULSE WIDTH
    UART_TX = 1      			        'STOP BIT
	pauseus UART_PERIOD_VAR_115200      'DELAY TO REACH APPROXIMATE PULSE WIDTH
	pauseus 3
    INPUT UART_TX                       'Change UART_TX back to INPUT (Set as INPUT when UART not is use to avoid programming conflicts)
return                         
				
WASTE_TIME:                            'DUMMY INSTRUCTION CYCLE FOR ACCURATE CLOCKING ON UART
return

        
'SUBROUTINES********************************************************************
disable
INTERRUPT_HANDLER:  '**NOTE: YOU CANNOT EXECUTE A SUBROUTINE WITHIN THE INTERRUPT HANDLER
    TMR0H = (65535 - TMR0_TICK_THRESHOLD) / 256     'SET HIGH BYTE OF TMR0 VALUE SO IT OVERFLOWS AT THE DESIRED PERIOD
    TMR0L = (65535 - TMR0_TICK_THRESHOLD) // 256    'SET LOW BYTE OF TMR0 VALUE SO IT OVERFLOWS AT THE DESIRED PERIOD
    INTCON.2 = 0                                                       'RESET TMR0 OVERFLOW INTERRUPT
    INT_pin = 1
    INT_PIN = 0
    resume     
enable
    
INIT_TMR0:
    T0CON = %10000000                               'ENABLES TIMER0, SETS AS 16-BIT, SET CLKOUT (T0CKI PIN) AS SOURCE, 
                                                    'INCREMENT ON RISING EDGE OF T0CKI PIN, ASSIGN PRESCALER OF 8 (PRECISION OF 250nS)
                                                    
    TMR0H = (65535 - TMR0_TICK_THRESHOLD) / 256     'SET HIGH BYTE OF TMR0 VALUE SO IT OVERFLOWS AT THE DESIRED PERIOD
    TMR0L = (65535 - TMR0_TICK_THRESHOLD) // 256    'SET LOW BYTE OF TMR0 VALUE SO IT OVERFLOWS AT THE DESIRED PERIOD
    INTCON.2 = 0    
    RETURN



        
